/*
 * Signal.c - generate various signals
 *
 * To understand FFTs you need to understand DFTs and
 * this code applies the DFT using correlation to the
 * samples generated by data gen.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <complex.h>
#include "signal.h"

#ifndef M_PI
#define M_PI		3.14159265358979323846	/* pi */
#endif

/*
 * alloc_buf( ... )
 *
 * Allocate a signal buffer. Basically this code is a very simple memory allocator
 * that starts at 0xc0000000 (where DRAM starts on the STM32F469-Disco board) and
 * starts eating chunks each time you allocate. There isn't an "actual" memory
 * allocator here so free doesn't actually do anything. Also it doesn't know
 * about malloc/free so it might give weird results if you've adjusted malloc
 * to use that space.
 */
sample_buffer *
alloc_buf(int size) {
	sample_buffer *res;

	res = malloc(sizeof(sample_buffer));
	res->data = malloc(sizeof(sample_t) * size);
	res->n = size;
	/* clear it to zeros */
	reset_minmax(res);
	clear_samples(res);

	/* return, data and 'n' are initialized */
	return res;
}

void
free_buf(sample_buffer *sb)
{
	free(sb->data);
	sb->data = 0x0;
	sb->n = 0;
	free(sb);
	return;
}

/*
 * add_cos( ... )
 *
 * Add in a signal at this frequency and amplitude into
 * the sample buffer.
 */
void
add_cos(sample_buffer *s, float f, float a)
{
	int	i;

	/*
	 * n is samples
	 * r is rate (samples per second)
	 * f is frequency (cycles per second)
	 * what span is (n / r) seconds / f = cyles /n is cycles per sample?
	 */
	for (i = 0; i < s->n; i++ ) {
		s->data[i] += (sample_t) (a * cosf(2 * M_PI * f * i / s->r));
		set_minmax(s, i);
	}
}


/*
 * add_triangle( ... )
 *
 * Add a triangle wave to the sample buffer.
 * Note it goes from -1/2a to +1/2a to avoid
 * having a DC component.
 */
void
add_triangle(sample_buffer *s, float f, float a)
{
	int i;
	float level = a / 2.0;
	float t;

	for (i = 0; i < s->n; i++) {
		s->data[i] += (sample_t)
			((a * modff(f * (float) i / (float) s->r, &t)) - level);
		set_minmax(s, i);
	}
}

/*
 * add_square( ... )
 *
 * Add a square wave to the sample buffer.
 * Note that it goes from -1/2a to +1/2a to avoid a DC component.
 */
void
add_square(sample_buffer *s, float f, float a)
{
	int i;
	float level = a / 2.0;
	float t;

	for (i = 0; i < s->n; i++) {
		s->data[i] += (sample_t)
			((modff(f * (float) i / (float) s->r, &t) >= .5) ? level : -level);
		set_minmax(s, i);
	}
}
// #define DEBUG_FFT

/* FFT data buffer */
complex float __fft_data[MAX_FFT_BINS];

/*
 * dft( ... )
 *
 * Compute the Discrete Fourier Transform using the
 * correlation method. 
 *
 * NOTE: It takes n^2 time to compute so above about 32 bins it
 * really does take a long time.
 */
void
calc_dft(sample_buffer *s, int bins, sample_buffer *mag)
{
	complex float t;
	int	i, k;

	/* run through each bin */
	mag->sample_max = mag->sample_min = 0;
	for (k = 0; k < bins; k++) {
		float current_freq;

		/* current frequency based on bin # and frequency span */
		current_freq = 2 * M_PI * k / (float) bins;

		__fft_data[k] = 0;
		mag->data[k] = 0;
		/* correlate this frequency with each sample */
		for (i = 0; i < s->n; i++) {
			float r;
			complex float sig;
			/*
			 * Compute correlation:
			 *	r is what the radians value at the current sample
			 *    this is 'wt' where 'i' is representing t
			 *  t then is e^-jwt
			 *  and t * sample_value is the correlation.
			 */
			r = current_freq * i;
			t = cosf(r) - sinf(r) * I;
			sig =  s->data[i];
			__fft_data[k] = __fft_data[k] + (t * sig);
		}

		/* magnitude of the correlation */
		mag->data[k] = cabsf(__fft_data[k]);

		/* track minimum and maximum */
		set_minmax(mag, k);
	}
}

/*
 * fft( ... )
 *
 * Compute the spectrum using the FFT algorithm. This is
 * very much faster than the DFT version. It requires that
 * the sample buffer be a power of 2. So 256, 512, 1024,
 * etc.
 */
void
calc_fft(sample_buffer *sig, int bins, sample_buffer *mag)
{
	int i, j, k;
	int q;
	float t;
	complex float alpha, uri, ur;

	/* and they must be a power of 2 */
	t = log(bins) / log(2);
	if (modff(t, &t) > 0) {
		return;
	}
	if (bins > MAX_FFT_BINS) {
		return;
	}

	q = (int) t;

#ifdef DEBUG_FFT
	printf("Bits per index is %d\n", q);
#endif

	/* This first bit is a reflection sort,
	 * Most people do a 'sort in place' of
	 * the source data, but I'm trying to preserve
	 * that original data for other use, so I
	 * 'sort into place' from the source into
	 * my temporary array __fft_data.
	 *
	 * The end result is each entry is 2^n away
	 * from its sibling.
	 */
	for (i = 0; i < bins; i++) {
		/* compute reflected index */
		for (k = 0, j = 0; j < q; j++) {
			k = (k << 1) | ((i >> j) & 1);
		}
		__fft_data[i] = sig->data[k];
	}

	/*
	 * now synthesize the frequency domain, 1 thru n
	 * frequency domain 0 is easy, its just the value
	 * in the bin because a 1 bin DFT is the spectrum
	 * of that DFT.
	 */
#ifdef DEBUG_FFT
	printf("FFT Calc: %d stage bufferfly calculation\n", q);
#endif

	for (i = 1; i <= q; i++) {
		int bfly_len = 1 << i;			/* Butterfly elements */
		int half_bfly = bfly_len / 2;		/* Half-the butterfly */

		/* nth root of K */
#ifdef DEBUG_FFT
		printf("Computing the roots of W(%d)\n", bfly_len);
#endif

		/* unity root value (complex) */
		ur = 1.0;

		/* This is the unity root increment (complex)
		 * If you multiply ur by this value 'n' times then
		 * ur will return to [1 + 0i]. 'n' in this case is
		 * bfly_len times. Technically the argument to the
		 * trancendentals would be 2 * pi / butterfly-span
		 * but since we calculate butterfly-span / 2 (half_bfly)
		 * we use algebra to simplify math to pi / half-bfly.
		 */
		uri = cosf(M_PI / half_bfly) - sinf(M_PI / half_bfly) * I;
		
		/*
		 * Combine two 2^i DFTs into a single
		 * 2^(i+1) DFT. So two 1 bin DFTs to
		 * a 2 bin DFT, two 2 bin DFTs to a 4
		 * bin DFT, etc. The number of times
		 * we convert is a function of how many
		 * 2^(i+1) bin DFTs are in the total
		 * number of bins. So for 512 bins (example)
		 * there are two hundred and fifty six  2-bin DFTs,
		 * one hundred and twenty eight 4-bin DFTs, all
		 * the way up to exactly one 512-bin DFT.
		 */
		for (j = 0; j < half_bfly ; j++) {
			for (k = j; k < bins; k += bfly_len) {
				/*
				 * Apply the FFT butterfly function to
			 	 * P[n], P[n + half_bfly]
				 *
				 * Alpha is the 180 degrees out point multiplied by
				 * the current unit root.
				 */
	
				alpha = __fft_data[k + half_bfly] * ur;
				/*
				 * Mathematically P[n + half_bfly] is 180 degrees
				 * 'further' than P[n]. So changing the sign on
				 * alpha (1 + 0i) => (-1 - 0i) is the equivalent
				 * value of alpha for that point in the transform.
				 *
				 * step 2, P[n]             = P[n] + alpha
				 *         P[n + half_bfly] = P[n] - alpha
				 *
				 * Sequence is important here, set P[n + h]
				 * before you change the value of P[n].
				 */
				__fft_data[k + half_bfly] = __fft_data[k] - alpha;
				__fft_data[k] += alpha;
				/*
				 * and that is it, except for scaling perhaps, if you want
				 * to (or need to) keep the bins within the precision
				 * of their numeric representation.
				 */
			}
			/*
			 * Now my multiplying UR by URI we save ourselves from
			 * recomputing the sin and cos, Euler tells us we can just
			 * keep multiplying and the values will go through a 
			 * sequence from 1 + 0, to 1 - i, to -1 + 0, to 1 + i and
			 * then back to 1 + 0.
			 */
			ur = ur * uri;

#ifdef DEBUG_FFT
			printf("    ... Increment UR to [%f, %f]\r", crealf(ur), cimagf(ur));
#endif
		}
#ifdef DEBUG_FFT
		printf("\n");
#endif
	}
#ifdef DEBUG_FFT
	printf("\nDone.\n");
#endif

	/*
	 * Final step for us, we now have a set of complex values describing 
	 * the spectrum but what we want are the magnitude. So we go back 
	 * through the computed spectra and using the complex version of the
	 * absolute value function we convert the complex values into magnitude
	 * values.
	 */
	for (i = 0; i < bins; i++) {
		mag->data[i] = cabsf(__fft_data[i]);
		set_minmax(mag, i);
	}
}
