/*
 * Signal.c - generate various signals
 *
 * To understand FFTs you need to understand DFTs and
 * this code applies the DFT using correlation to the
 * samples generated by data gen.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <complex.h>
#include "signal.h"

/*
 * alloc_buf( ... )
 *
 * Allocate a signal buffer. Basically this code is a very simple memory allocator
 * that starts at 0xc0000000 (where DRAM starts on the STM32F469-Disco board) and
 * starts eating chunks each time you allocate. There isn't an "actual" memory
 * allocator here so free doesn't actually do anything. Also it doesn't know
 * about malloc/free so it might give weird results if you've adjusted malloc
 * to use that space.
 */
sample_buffer *
alloc_buf(int size) {
	sample_buffer *res;

	res = malloc(sizeof(sample_buffer));
	res->data = malloc(sizeof(sample_t) * size);
	res->n = size;
	/* clear it to zeros */
	reset_minmax(res);
	clear_samples(res);

	/* return, data and 'n' are initialized */
	return res;
}

void
free_buf(sample_buffer *sb)
{
	free(sb->data);
	sb->data = 0x0;
	sb->n = 0;
	free(sb);
	return;
}

/*
 * add_cos( ... )
 *
 * Add in a signal at this frequency and amplitude into
 * the sample buffer. 
 */
void
add_cos(sample_buffer *s, float f, float a)
{
	int	i;

	/*
	 * n is samples
	 * r is rate (samples per second)
	 * f is frequency (cycles per second)
	 * what span is (n / r) seconds / f = cyles /n is cycles per sample?
	 */
	for (i = 0; i < s->n; i++ ) {
		s->data[i] += (sample_t) (a * cosf(2 * M_PI * f * i / s->r));
		set_minmax(s, i);
	}
}


/*
 * add_triangle( ... )
 *
 * Add a triangle wave to the sample buffer.
 * Note it goes from -1/2a to +1/2a to avoid
 * having a DC component.
 */
void
add_triangle(sample_buffer *s, float f, float a)
{
	int i;
	float level = a / 2.0;
	float t;

	for (i = 0; i < s->n; i++) {
		s->data[i] += (sample_t) 
			((a * modff(f * (float) i / (float) s->r, &t)) - level);
		set_minmax(s, i);
	}
}

/*
 * add_square( ... )
 *
 * Add a square wave to the sample buffer.
 * Note that it goes from -1/2a to +1/2a to avoid a DC component.
 */
void
add_square(sample_buffer *s, float f, float a)
{
	int i;
	float level = a / 2.0;
	float t;

	for (i = 0; i < s->n; i++) {
		s->data[i] += (sample_t) 
			((modff(f * (float) i / (float) s->r, &t) >= .5) ? level : -level);
		set_minmax(s, i);
	}
}

/* 
 * dft( ... )
 *
 * Compute the Discrete Fourier Transform using the
 * correlation method. This out of DSP for engineers and scientists 
 * NOTE: It takes n^2 time to compute so above about 32 bins it
 * really does take a long time.
 */
void
calc_dft(sample_buffer *s, float min_freq, float max_freq, int bins, 
	sample_buffer *rx, sample_buffer *im, sample_buffer *mag)
{
	int	i, k;

	/* run through each bin */
	reset_minmax(rx); 
	reset_minmax(im);
	mag->sample_max = mag->sample_min = 0;
	for (k = 0; k < bins; k++) {
		float current_freq;

		/* don't overwrite random memory, so check array bound */
		if ((k >= rx->n) || (k >= im->n) || (k >= mag->n)) {
			break;
		}
		/* current frequency based on bin # and frequency span */
		current_freq = min_freq + k * (max_freq - min_freq) / (float) bins;

		rx->data[k] = 0;
		im->data[k] = 0;
		mag->data[k] = 0;
		/* correlate this frequency with each sample */
		for (i = 0; i < s->n; i++) {
			float r;

			/* compute correlation, r is radians 
			 * 2pi is 'radians/cycle'
			 * current_freq is 'cycles/second'
			 * i is 'sample'
			 * s->r is 'sample(s)/second'
			 *
			 *       radians   cycles    sample   seconds
			 * r =   ------- * ------- * ------ * -------
 			 *        cycle    seconds     1      samples
			 *
			 * note that cycle cancels cycles, sample cancels samples, and
			 * seconds cancels seconds leaving you with just radians.
			 */
			r = 2 * M_PI * current_freq * i / s->r;
			rx->data[k] = rx->data[k] + s->data[i] * cosf(r);
			im->data[k] = im->data[k] + (- s->data[i] * sinf(r));
		}

		
		/* magnitude of the correlation */
		mag->data[k] = 
				sqrt(rx->data[k] * rx->data[k] + im->data[k] * im->data[k]);

		/* track minimum and maximum */
		set_minmax(rx, k);
		set_minmax(im, k);
		set_minmax(mag, k);

	}

}

#define DEBUG_FFT

#define MAX_FFT_BINS	1024
/* FFT data buffer */
complex float __fft_data[MAX_FFT_BINS];
#ifdef DEBUG_FFT
uint16_t	indices[MAX_FFT_BINS];
#endif

/* compute the magnitude of the complex phasor */
#define MAGNITUDE(C)	sqrtf(creal((C)) * creal((C)) + cimag((C)) * cimag((C)))

/*
 * fft( ... )
 *
 * Given the set of complex points P represented
 * by the two vectors re->data[P], im->data[P], compute
 * the fast fourier transform in place. The length of
 * re and im must be equal and a power of 2.
 */
void
calc_fft(sample_buffer *sig, int bins, sample_buffer *mag)
{
	int i, j, k;
	int q;
	float t;
	complex float alpha, uri, ur;
	uint16_t	t16;

	/* and they must be a power of 2 */
	t = log(bins) / log(2);
	if (modff(t, &t) > 0) {
		return;
	}
	if (bins > MAX_FFT_BINS) {
		return;
	}
	/* signal with zero imaginary component */
	for (i = 0; i < bins; i++) {
		__fft_data[i] = sig->data[i];
#ifdef DEBUG_FFT
		indices[i] = i;
#endif
	}

	q = (int) t;

	printf("Bits per index is %d\n", q);
	/* This first bit is a reflection sort,
	 * note that any index that is the same
	 * LSB to MSB as MSB to LSB is not swapped.
	 * we know 0 and n-1 will be symmetric so we
	 * don't even look at them.
	 */
	for (i = 1; i < (bins - 1); i++) {
		/* compute reflected index */
		for (k = 0, j = 0; j < q; j++) {
			k = (k << 1) | ((i >> j) & 1);
		}
		/*
		 * Only swap lower value for higher value this
	 	 * way we avoid swapping things twice when when
		 * come across the higher index.
		 */
		if (k > i) {
			complex float tmp;
#ifdef DEBUG_FFT

			
			t16 = indices[i];
			indices[i] = indices[k];
			indices[k] = t16;
#endif
			/* swap values */
			tmp = __fft_data[i];
			__fft_data[i] = __fft_data[k];
			__fft_data[k] = tmp;
		}
	}

	/* 
	 * now synthesize the frequency domain, 1 thru n
	 * frequency domain 0 is easy, its just the value
	 * in the bin because a 1 bin DFT is the spectrum
	 * of that DFT.
	 */
#ifdef DEBUG_FFT
	printf("FFT Calc: %d stage bufferfly calculation\n", q);
	printf("Reverse Sort: [");
	for (i = 0; i < bins; i++) {
		printf("%d, ", indices[i]);
	}
	printf("]\n");
#endif

	for (i = 1; i < q; i++) {
		int bfly_len = 2 << i;			/* Butterfly elements */
		int half_bfly = 2 << (i-1);		/* Half-the butterfly */

		/* nth root of K */
		printf("Computing the roots of W(%d)\n", bfly_len);
		/* unity root value (complex), nth instance of the Unity Root */
		ur = 1.0;
		/* unity root increment (complex) */
		uri = cosf(2 * M_PI / bfly_len) - sinf(2 * M_PI / bfly_len) * I;
		
		/*
		 * Run the calculation for each root.
		 * We run 0 to nr - 1, because we take
		 * advantage of the symmetry, at bin 0
		 * we have root n, and at bin 0 + nr we
		 * root n + 180 degrees (aka (- root n))
		 * We apply both and do half number of
		 * multiplies, win!
		 */
		for (j = 0; j < half_bfly ; j++) {
			/* run the calculation across all bins */
//			printf(" Apply '%d'th root of %d, to [%d] and [%d] %d times\n", j, bfly_len,
//					j, j + half_bfly, bins/bfly_len);
			for (k = j; k < bins; k += bfly_len) {
				/*
				 * Apply the FFT butterfly function to
			 	 * P[n], P[n + half_bfly]
				 * step 1, multiply our unity root by p[n + half_bfly]
				 */
				alpha = __fft_data[k + half_bfly] * ur;

				/* now we sum it to P[k], and subtract it from P[k + nr] */
				__fft_data[k] += alpha; 
				__fft_data[k + half_bfly] -= alpha;
#ifdef DEBUG_FFT
				t16 = indices[k];
				indices[k] = indices[k + half_bfly];
				indices[k + half_bfly] = t16;
#endif
			}
			/* advance to the next fraction of the unity root */
			ur = ur * uri;
		}
	}
#ifdef DEBUG_FFT
	printf("FFT Calc: post %d stage bufferfly calculation\n", q);
	printf("Reverse Sort: [");
	for (i = 0; i < bins; i++) {
		printf("%d, ", indices[i]);
	}
	printf("]\n");
#endif
	for (i = 0; i < bins; i++) {
		mag->data[i] = MAGNITUDE(__fft_data[i]);
		set_minmax(mag, i);
	}
}
