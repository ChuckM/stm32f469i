/*
 * Discrete Fourier Transform
 *
 * To understand FFTs you need to understand DFTs and
 * this code applies the DFT using correlation to the
 * samples generated by data gen.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

/*
 * This is a bucket of samples, is is 'n' samples long.
 * And it represents collecting them at a rate 'r' per
 * second. So a total of n / r seconds worth of signal.
 */
typedef struct {
	float	*data;
	int		n;
	int		r;
} sample_buffer;

float cos_basis(int, float);
float sin_basis(int, float);
void add_freq(sample_buffer *, float, float);

/*
 * basis function
 *
 * This is a basis function (cos)
 *	f is the frequency
 *	t is the time.
 */
float
cos_basis(int f, float t)
{
	return cos(2 * M_PI * f * t);
}

/*
 * This is the sin basis function
 */
float
sin_basis(int f, float t)
{
	return sin(2 * M_PI * f * t);
}

/*
 * add_freq( ... )
 *
 * Add in a signal at this frequency and amplitude into
 * the sample buffer. 
 *
 * Scaled to a 12 bit value (0 == 2048, -1 = 0, +1 = 2048)
 */
void
add_freq(sample_buffer *s, float f, float a)
{
	int	i;
	float *buf = s->data;

	/*
	 * n is samples
	 * r is rate (samples per second)
	 * f is frequency (cycles per second)
	 * what span is (n / r) seconds / f = cyles /n is cycles per sample?
	 */
	for (i = 0; i < s->n; i++ ) {
		*buf += a * cos(2 * M_PI * f * i / s->r);
		buf++;
	}
}

#define SAMP_SIZE 1024
#define SAMP_RATE 8192

float r_x[SAMP_SIZE / 2];
float i_x[SAMP_SIZE / 2];
int ri_len = SAMP_SIZE / 2;

void gen_data(void);

void
gen_data(void)
{
	sample_buffer	sb;
	float	s_data[SAMP_SIZE];
	float data_min, data_max;
	int	i, k, f;

	sb.data = s_data;
	sb.n = SAMP_SIZE;
	sb.r = SAMP_RATE;	/* 8 khz sample rate */

	/* clear sample data */
	memset(s_data, 0, sizeof(s_data));

	/* why does 600 give us zero? */
	add_freq(&sb, 300, 2);
	add_freq(&sb, 200, 2);
	add_freq(&sb, 100, 1);
	data_min = data_max = 0;
	for (i = 0; i < sb.n; i++) {
		data_min = (*(sb.data + i) < data_min) ? *(sb.data+i) : data_min;
		data_max = (*(sb.data + i) > data_max) ? *(sb.data+i) : data_max;
	}
#ifdef DEBUG
	scale = 60.0 / (data_max - data_min);
	printf("Min/Max - %f, %f\n", data_min, data_max);
	printf("Scale/Offset - %f, %f\n", scale, offset);
#endif
	
	printf("Generating data ... \n");

	for (i = 1; i < SAMP_SIZE/2; i++) {
		float t;

		f = (4096 * i) / 4096;
		r_x[i] = 0;
		i_x[i] = 0;
		for (k = 0; k < SAMP_SIZE; k++) {
			t = (float) k / (float) SAMP_RATE;
			r_x[i] += s_data[k] * cos_basis(f, t);
			i_x[i] += s_data[k] * sin_basis(f, t);
		}
		r_x[i] = (2 * r_x[i]) / (SAMP_SIZE / 2);
		i_x[i] = (-2 * i_x[i]) / (SAMP_SIZE / 2);
		printf("%d of %d\n", i, SAMP_SIZE/2);
#ifdef DEBUG
		printf("DFT[%3d] (%10.2fhz) = %10.4f, %10.4f \t:", f, q, r_x[i], i_x[i]);
		r_val = 40 * r_x[i] + 40;
		i_val = 40 * i_x[i] + 40;
		for (j = 0; j < 80; j++) {
			if ((j > i_val) && (j > r_val)) {
				break;
			}
			if (j == i_val) {
				printf("I");
			} else if (j == r_val) {
				printf("R");
			} else if (j == 40) {
				printf("+");
			} else {
				printf(" ");
			}
		}
		printf("\n");
#endif
	}
	printf("Done.\n");
}
